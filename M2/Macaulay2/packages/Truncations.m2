-- TODO:
--  1. this should work under quotient rings, exterior algebras, 
--  2. this should be fast for singly graded cases
--  3. make sure doc for the internal routine is correct: 
--      calls basis with an obscure undocumented option.
--      and the result is wrong for multi-gradings
--      and the doc for truncate is incorrect.
--  4. heft vector: we are doing WAY TOO MUCH work here.
--     heft vector doesn't need to be inside the cone.
--     perhaps start with simplicial part of the cone
newPackage(
        "Truncations",
        Version => "0.1", 
        Date => "12 Oct 2018",
        Authors => {
            {
                Name => "David Eisenbud", 
                Email => "de@msri.org", 
                HomePage => "http://www.msri.org/~de"},
            {
                Name => "Mike Stillman", 
                Email => "mike@math.cornell.edu", 
                HomePage=>"http://www.math.cornell.edu/~mike"}
            },
        Headline => "truncation of a module",
        DebuggingMode => true
        )

export {
    "trunc"
    }

trunc = method()
trunc(List,Module) := (D,M)->(
    --D can be a list of integers, of length = degreeLength ring M,
    --representing a single multi-degree, or a list of lists of multidegrees.
    --the function returns the submodule of M monomials of degree >=d for some d in D
    --requires that all the components of the degrees of R are all >=0.
    R := ring M;

    --in the easy case of a multiprojective space, don't bother with the aux ring.
    deglist := R_*/degree;
    if all(deglist, d->(sum d == 1 and all(d, i-> i>=0))) then return trunc0(D,M);

    --construct an embedding phi1 of R into a standard graded auxilliary ring:
    n := numgens R;
    dl := degreeLength R;
    --make a new ring T with n*dl variables, one for each (variable,degree component).
    kk := coefficientRing R;
    t := symbol t;
    T := kk[t_(0,0)..t_(n-1,dl-1)];
   --define a map R->T
    e:=0;
    targ := apply(numgens R, i -> (
	e = degree R_i;
	product(dl,j->t_(i,j)^(e_j))
	    ));
    phi1 := map(T,R,targ);

    --now construct the truncation, using the ring map over and over    
    if class D_0 =!= List then (
        L := gens M;
        dM := (degrees (gens M))_1;
        M1 := apply(#dM, i-> 
	    trunc(positivePart(D-dM_i),phi1)*image(L_{i}));
        trim sum M1
        )
    else
        trim sum(D, d->trunc(d,M))
    )

positivePart = method()
positivePart List := L -> apply(L, ell-> max(ell,0))

trunc0 = method()
trunc0(List, Module) := (D,M) ->(
    --A fix for the basic truncate command in the case of a module on multi-projective space.
    --If i is a multi-degree, then the result of truncate(i,M)
    --should be the submodule generated by all elements of degree >= i in the partial order.
    --The script assumes that the degrees of the variables in ring M are the basis vectors,
    --not something more exotic.
    if class D_0 =!= List then (
    dl := degreeLength M;
    L := gens M;
    dM := (degrees (gens M))_1;
    if all(dM, m -> all(dl, i-> m_i<=D_i)) then return image basis(D,M);
    S := ring M;
    M1 := apply(#dM, i-> 
	    ideal(basis(positivePart(D-dM_i),S,Truncate=>true))*image (L_{i}));
    sum M1) else
    trim sum(D, d->trunc0(d,M))
    )

-- The following routine should use integer point polyhedral code, as in normaliz?
trunc(List,RingMap) := (d,phi) ->(
    --for the moment we need T to be of the special form greated in trunc(List, Ring):
    --namely, variable t_(i,j) etc.
    --note that t_(i,j) = T_(i+n*j).
    R := source phi;
    n := numgens R;
    dl := degreeLength R;
    T := target phi;
    -- should have n*dl variables t_(i,j), 0<=i<=n-1, and 0<=j<=dl-1 -- that is,
    -- one for each pair (variable, degree component).
    -- now find the ideal in T of elements of degree >= d.
    -- Td := product(dl,j->(ideal(apply(n,i->t_(i,j))))^(d_j));
    Td := product(dl,j->(ideal(apply(n,i->T_(i+n*j))))^(d_j));
    -- the desired ideal is a kernel
    ker(map(T/Td,T)*phi)  -- TODO: this is a monomial map, use normaliz. or oerhaps make kernel faster.
    )

trunc(List, Ring) := (d,R) ->(
    --produce the ideal in R of all monomials of degree >=D
    --requires that all the components of the degrees of R are all >=0.
    n := numgens R;
    dl := degreeLength R;
    --make a new ring T with n*dl variables, one for each (variable,degree component).
    kk := coefficientRing R;
    t := symbol t;
    skewvarsT := if not R.?SkewCommutative then {} 
                 else (
                    skewvarsR := R.SkewCommutative;
                    flatten for i in skewvarsR list for j from 0 to dl-1 list t_(i,j)
                    );
    T := kk[t_(0,0)..t_(n-1,dl-1), SkewCommutative=>skewvarsT];
      
   --now find the ideal Td in T of elements of degree >= d.
    Td := product(dl,j->(ideal(apply(n,i->t_(i,j))))^(d_j));
   --define a map R->T
    e:=0;
    targ := apply(numgens R, i -> (
	e = degree R_i;
	product(dl,j->t_(i,j)^(e_j))
	    ));
    phi1 := map(T,R,targ);
       --the desired ideal is a kernel of the composite map R --> T/Td.
    U := T ** R;
    Utarg := ideal apply(numgens R, i -> (
	e = degree R_i;
	sub(R_i,U) - sub(product(dl,j->t_(i,j)^(e_j)),U)
        ));
    J := Utarg + sub(Td, U);
    return trim ideal sub(selectInSubring(1, gens gb J), R);
    psi := map(T/Td,T)*phi1;
    psi
    --ker psi
    )

TEST ///
  S = ZZ/101[a,b, Degrees =>{{0,1},{1,0}}]
  M = S^{-{5,2}, -{2,3}}
  D = {4,3}
  E = {{4,3},{3,4}}
  assert(trunc(D,S) == ideal(a^3*b^4))
  assert(trunc(D,S^1) == image matrix {{a^3*b^4}})
  assert(trunc(E,S^1) == image matrix {{a^3*b^4, a^4*b^3}})
  assert(trunc(E,M) == image(map(S^{{-5, -2}, {-2, -3}},, {{0, 0, a}, {b^2, a*b, 0}})))
-*
  trunc0(D,S^1)
  trunc0(D,M)
  trunc(D,M)
  trunc0(E,M)
*-
///

TEST ///
  kk = ZZ/101
  R = kk[a,b,c,Degrees =>{2:{3,4},{7,5}}]
  d = {5,6}
  D = {d,reverse d}

  elapsedTime J = trunc(d,R)
  M = R^1
  J = trunc(d,R^1)
  J_*/degree
  K = trunc(D,R^1)
///

beginDocumentation()
end--

doc ///
Key
  Truncation
Headline
Description
  Text
  Example
Caveat
SeeAlso
///

doc ///
Key
Headline
Usage
Inputs
Outputs
Consequences
Description
  Text
  Example
  Code
  Pre
Caveat
SeeAlso
///

TEST ///
-- test code and assertions here
-- may have as many TEST sections as needed
///

end--
restart
loadPackage "Truncations"

-- test of normaliz, to see if it does what we need here:
restart
needsPackage "Normaliz"
needsPackage "NormalToricVarieties"

V = smoothFanoToricVariety(3,5)
rays V
max V
S = ring V
A = transpose matrix degrees S
C = posHull A
C2 = dualCone C
rays C2

-- how to create Ax >= b, x >= 0?
-----------------------------------------------------------------------
---- notes taken by MS and DE in October 2018 for to do for this package
-----------------------------------------------------------------------
restart
load "trunc.m2"
R = ZZ/101[a..d, Degrees=>{3,5,7,9}]
trunc({15}, R)

E = ZZ/101[e_0..e_10, SkewCommutative => true]
trunc0({10}, E^1)
trunc0({11}, E^1)
trunc({3}, E)

gens gb oo

U = E ** T

-------
in trunc(List,Module):
  make the ring U directly, not T.
  instead of phi1, make the ideal we had in trunc(List,Ring).
  
1. change all multi-degrees to be positive. (utility routine)
2. handle quotient rings and modules over them
3. handle exterior algebra
4. trunc creates a ring, which should perhaps be skew commutative.
6. incorporate trunc-new into this package Truncation.

What we really want, is generators for the semigroup
{x in ZZ^n(>=0), Ax >= b}

-- mike doodling about fixing basis command in engine:
Matrix::basis
  KBasis::k_basis(7 arguments)

  
How best to find
  {x in ZZ^n(>=0), Ax = b}
  
  x in ZZ^n
  A is d x n.
  b is in ZZ^d.
  
  Find lattice points in Ax=b, x >= 0.
  
  if possible, Let A1 = Q^-1 * A * P (or A_perm) = (I | C), C is d x (n-d).
  then create a polytope in (n-d) space, then extend each monomial to ZZ^n.
  
-- given a matrix A, d x n whose columns are the degrees of the variables (in ZZ^d),
-- find, if possible a minor with det +-1.  If none, how to handle this?


-- notes 10 Nov 2018, DE, MS
want to solve systems of linear equalities and inequalities in ZZ^n

specifically:
  A be the degree matrix (d x n, n = #vars)
  
  truncate(R, D), D in ZZ^d.
  solve Ax >= D, (might include x >= 0)

  truncate(M, D), M = module.
    take each generator degree E, take Ax >= D-E, then mult each gen
    in degree E by these monomials.



  
  